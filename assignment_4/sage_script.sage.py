

# This file was *autogenerated* from the file sage_script.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_10 = Integer(10); _sage_const_0p000000001 = RealNumber('0.000000001')
from sage.all import *

# Function for calculating the distance of plane from a point

def distance_from_plane_square(x, y, z, points):
    squared_distances = [(x * point[_sage_const_0 ] + y * point[_sage_const_1 ] + z * point[_sage_const_2 ] - _sage_const_1 ) ** _sage_const_2  for point in points]
    return sum(squared_distances)

# Define variables

x, y, z = var('x y z')

# Initialize theta with random values

initial_theta = matrix([[randrange(-_sage_const_10 , _sage_const_10 )], [randrange(-_sage_const_10 , _sage_const_10 )], [randrange(-_sage_const_10 , _sage_const_10 )]])
theta = initial_theta
print('Initial Theta:', theta.transpose())

# Read points from file

points = []
with open('points.csv', 'r') as f:
    next(f)  # Skip the first line
    for line in f.readlines():
        coords = line.strip().split(',')
        point = vector([float(coord) for coord in coords])
        points.append(point)

# Initialize iteration count
iter = _sage_const_0 
f = distance_from_plane_square(x, y, z, points)

# Loop until error is less than delta or maximum iterations reached

while distance_from_plane_square(theta[_sage_const_0 , _sage_const_0 ], theta[_sage_const_1 , _sage_const_0 ], theta[_sage_const_2 , _sage_const_0 ], points) > _sage_const_0p000000001 :
    # Calculate error
    error_value = f.subs({x: theta[_sage_const_0 , _sage_const_0 ], y: theta[_sage_const_1 , _sage_const_0 ], z: theta[_sage_const_2 , _sage_const_0 ]})


# Calculate Hessian matrix and gradient matrix

    hessian_matrix = matrix([[diff(diff(f, x), x), diff(diff(f, x), y), diff(diff(f, x), z)],
                             [diff(diff(f, y), x), diff(diff(f, y), y), diff(diff(f, y), z)],
                             [diff(diff(f, z), x), diff(diff(f, z), y), diff(diff(f, z), z)]])

    gradient_matrix = matrix([[diff(f, x)], [diff(f, y)], [diff(f, z)]])

    # Substitute values into Hessian and gradient matrices
    hessian_matrix = hessian_matrix.subs({x: theta[_sage_const_0 , _sage_const_0 ], y: theta[_sage_const_1 , _sage_const_0 ], z: theta[_sage_const_2 , _sage_const_0 ]})
    gradient_matrix = gradient_matrix.subs({x: theta[_sage_const_0 , _sage_const_0 ], y: theta[_sage_const_1 , _sage_const_0 ], z: theta[_sage_const_2 , _sage_const_0 ]})
# Calculate delta theta and update theta
    try:
        delta_theta = hessian_matrix.inverse() * gradient_matrix
        theta -= delta_theta
    except Exception as e:
        print('Error occurred during theta update:', e)

    # Calculate error after theta update
    updated_error_value = f.subs({x: theta[_sage_const_0 , _sage_const_0 ], y: theta[_sage_const_1 , _sage_const_0 ], z: theta[_sage_const_2 , _sage_const_0 ]})
    
    # Increment iteration count
    iter += _sage_const_1 

# Print the optimal matrix for theta and number of epochs required to achieve this
print('Optimal Theta:', theta.transpose())
print('Epochs:', iter)

